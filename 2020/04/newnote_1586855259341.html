<attachment contenteditable="false" data-atts="%5B%5D" data-aid=".atts-6662a25a-efb7-46f9-a2c4-7f6d787c58ad"></attachment><h2>每天都在用class，你到底对它了解多小？</h2><p><span style="color: var(--weui-LINK);">创业者连萌</span>&nbsp;<span style="color: rgba(0, 0, 0, 0.3);">3天前</span></p><p>以下文章来源于LinDaiDai&nbsp;，作者LinDaiDai</p><p><br></p><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5NTQ4ODc5MA==&amp;mid=2247484781&amp;idx=4&amp;sn=6764808984a19a00cd76c0ec9c94ed86&amp;chksm=a6f6f01491817902be72c381e14108571bc4030e78e826b5cd80edf2708823a0836cccb09307&amp;scene=21#" target="_blank" style="color: var(--weui-LINK); background-color: rgb(238, 238, 238);"><img src="http://wx.qlogo.cn/mmhead/Q3auHgzwzM74w7IHNEGujsJwjfWVOt7yxtpLMKlwAReIFbktOIW8EQ/0" alt="LinDaiDai"></a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5NTQ4ODc5MA==&amp;mid=2247484781&amp;idx=4&amp;sn=6764808984a19a00cd76c0ec9c94ed86&amp;chksm=a6f6f01491817902be72c381e14108571bc4030e78e826b5cd80edf2708823a0836cccb09307&amp;scene=21#" target="_blank" style="background-color: rgb(247, 247, 247); color: rgba(0, 0, 0, 0.9);"><strong>LinDaiDai</strong></a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5NTQ4ODc5MA==&amp;mid=2247484781&amp;idx=4&amp;sn=6764808984a19a00cd76c0ec9c94ed86&amp;chksm=a6f6f01491817902be72c381e14108571bc4030e78e826b5cd80edf2708823a0836cccb09307&amp;scene=21#" target="_blank" style="background-color: rgb(247, 247, 247); color: var(--weui-LINK);">选一个方向, 定一个时间, 剩下的只管努力和坚持. 此公众号会不定期的更新出一些关于前端方面的知识好文以及我的一些原创文章. 希望你能和霖呆呆一起, 在前端的道路上越走越远, 盼望看到我们共同的成长.</a></p><h2 class="ql-align-justify"><strong>前言</strong></h2><p class="ql-align-justify">你盼世界，我盼望你无<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">bug</code>。Hello 大家好！我是霖呆呆！</p><p class="ql-align-justify">（这个号称全订阅号最臭不要脸的男人又成功用标题把你骗了进来，哈哈 😄）</p><p class="ql-align-justify"><code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">"先给你个三连"</code></p><p class="ql-align-justify"><img src="https://mmbiz.qpic.cn/mmbiz_jpg/gBEW5LPs1zo0nSrFKAial87mdKSU3qQLZtgp8QZj7I4uamCgKbRA2m05UdbkVJ0NJRBKFXhD4frqDShlnSdor9Q/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1"></p><p class="ql-align-justify">滴滴滴～ 又是一星期没见了</p><p class="ql-align-justify">看着右侧目录这么一大排的<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">题目一、题目二、题目三...</code>你是不很开心，终于...又有题做了。</p><p class="ql-align-justify">你会发现霖呆呆的文章每期都是这么丰满，字动不动就是上万，题目动不动就是好几十题，我也很担心你们会不会不想去看。</p><p class="ql-align-justify">包括我自己其实也不是特别愿意去看一些大篇幅的文章。</p><p class="ql-align-justify">(当然，炒鸡棒的文章除外哈，比如掘金上都超好看)</p><p class="ql-align-justify">因此最近我转化了一种思路，将一些知识点化为题目，让我们在做题的同时来消化理解它。</p><p class="ql-align-justify">这样就避免了整篇文章都是概念性的东西，有些枯燥😅。</p><p class="ql-align-justify">(不过对于一些硬性必须记的东西大家也千万不能偷懒得记着啊)</p><p class="ql-align-justify">而且这几天我发现了一些很奇怪的事情，有些读者就是冲着我文章的评论来的。就比如我的那篇Promise面试题，一哥们就挑明了和我说：</p><p class="ql-align-justify"><code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">"我是直接看的评论，很精彩"</code></p><p class="ql-align-justify">我是直接看评论的...</p><p class="ql-align-justify">你跳过霖呆呆辛辛苦苦写的<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">1.1w字</code>的内容，点到评论区看评论？！😭</p><p class="ql-align-justify">最最最主要的是！！！😭</p><p class="ql-align-justify">你还不点赞...不点赞...点赞...赞！！！😭</p><p class="ql-align-justify">我...设计师...给我配个我在风中凌乱的表情包。</p><p class="ql-align-justify">[表情包风中凌乱～]</p><p class="ql-align-justify"><code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">"你？！开除！"</code></p><p class="ql-align-justify">哈哈哈～</p><p class="ql-align-justify"><code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">玩归玩闹归闹,JS继承把你教！</code></p><p class="ql-align-justify">其实这是一篇系列型的文章，让我们转到系列介绍去看看吧...</p><p class="ql-align-justify">等会见...</p><h2 class="ql-align-justify"><strong>JS继承系列介绍</strong></h2><p class="ql-align-justify">看过霖呆呆文章的小伙伴应该都感觉的出，我比较喜欢针对每个知识点出一些比较<strong style="color: rgb(248, 57, 41);">细节的题目</strong>，然后将这些细节连串起来最后组合成大家<strong style="color: rgb(248, 57, 41);">最爱的综合题</strong>😄。</p><p class="ql-align-justify">该系列主要为了让我们彻底理解<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">JavaScript</code>面向对象的三大特性：<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">封装</code>、<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">继承</code>、<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">多态</code>。</p><p class="ql-align-justify"><code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">"咦～这三大特性我知道啊，大清都完了你还在这谈"</code></p><p class="ql-align-justify">啊~ 看到这里你先别着溜，开始的我也是和你一样觉得背背概念，写点小例子就懂了，直到霖呆呆自己给自己出了几道<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">魔鬼</code>题，我才发现之前对它们的理解还是不太全面...因此才有了本系列。</p><p class="ql-align-justify">系列总目录：</p><ul><li class="ql-align-justify">封装</li><li class="ql-align-justify ql-indent-1"><code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">ES6</code>之前的封装-构造函数</li><li class="ql-align-justify ql-indent-1"><code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">ES6</code>之后的封装-<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">class</code></li><li class="ql-align-justify">继承</li><li class="ql-align-justify ql-indent-1">原型链继承</li><li class="ql-align-justify ql-indent-1">构造继承</li><li class="ql-align-justify ql-indent-1">组合继承</li><li class="ql-align-justify ql-indent-1">寄生组合继承</li><li class="ql-align-justify ql-indent-1">原型式继承</li><li class="ql-align-justify ql-indent-1"><code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">class</code>中的<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">extends</code>继承</li><li class="ql-align-justify">多态</li></ul><p class="ql-align-justify">(在开始写之前本想要一篇文章全部搞定的，但是发现字真太多了，所以才分开来写，而且我终于又可以用我最爱的<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">绯红</code>主题了 😄)</p><p class="ql-align-justify">这一章节主要是想向大家介绍一下<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">JS</code>面向对象的第一大特性-<strong style="color: rgb(248, 57, 41);">封装</strong>，也是为了给后面最重要的<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">继承</code>打好基础。</p><p class="ql-align-justify">题目也不太多，总共17道，算是牛刀小试吧。</p><p class="ql-align-justify">通过阅读本章节你可以学习到：</p><ul><li class="ql-align-justify"><code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">ES6</code>之前的封装-构造函数</li><li class="ql-align-justify"><code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">ES6</code>之后的封装-<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">class</code></li></ul><h2 class="ql-align-justify"><strong>前期准备</strong></h2><p class="ql-align-justify">先来理解一些最最最基本的概念：</p><p class="ql-align-justify">（一）</p><pre class="ql-syntax ql-align-justify" spellcheck="false">// 1. 构造函数
function Cat (name) {
    this.name
}
// 2. 构造函数原型对象
Cat.prototype
// 3. 使用Cat构造函数创建的实例'乖乖'
var guaiguai = new Cat('guaiguai')
// 4. 构造函数的静态方法,名为fn
Cat.fn = function () {}
// 5. 原型对象上的方法,名为fn
Cat.prototype.fn = function () {}
</pre><p class="ql-align-justify"><img src="https://mmbiz.qpic.cn/mmbiz_png/gBEW5LPs1zo0nSrFKAial87mdKSU3qQLZLBR3Co4p6ZFXxYT3TxCPaOMsics3LrpP0oibvjMN6Yuu7KgNAxTElIIA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1">实例原型链</p><p class="ql-align-justify">（二）</p><p class="ql-align-justify"><code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">语法糖</code>的意思是现有技术本可以实现，但是采用某种写法会更加简洁优雅。</p><p class="ql-align-justify">比如<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">class</code>就是语法糖。</p><p class="ql-align-justify">（三）</p><p class="ql-align-justify">原型链继承的思维导图</p><p class="ql-align-justify">(这个暂时看不懂没关系，在继承那一章节中会讲到)</p><p class="ql-align-justify"><img src="https://mmbiz.qpic.cn/mmbiz_jpg/gBEW5LPs1zo0nSrFKAial87mdKSU3qQLZkGbPmPSPdatgqZIxDxpYTwNGuspbuAC0zMGau2sCBiaPIxI4XIudCrw/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1"></p><p class="ql-align-justify"><br></p><h3 class="ql-align-justify"><span style="color: rgb(165, 213, 93);">封装</span></h3><p class="ql-align-justify">把客观事物封装成抽象的类，隐藏属性和方法，仅对外公开接口。</p><h3 class="ql-align-justify"><span style="color: rgb(165, 213, 93);">1. ES6之前的封装</span></h3><p class="ql-align-justify">（虽然以下内容是概念部分，但是对你解题很有帮助哦，请务必仔细阅读它 😁）</p><p class="ql-align-justify">都知道<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">ES6</code>的<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">class</code>实际就是一个语法糖，那么在<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">ES6</code>之前，是没有类这个概念的，因此是借助于<strong style="color: rgb(248, 57, 41);">原型对象</strong>和<strong style="color: rgb(248, 57, 41);">构造函数</strong>来实现。</p><ul><li class="ql-align-justify">私有属性和方法：只能在构造函数内访问不能被外部所访问(在构造函数内使用<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">var</code>声明的属性)</li><li class="ql-align-justify">公有属性和方法(或实例方法)：对象外可以访问到对象内的属性和方法(在构造函数内使用<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">this</code>设置，或者设置在构造函数原型对象上比如<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">Cat.prototype.xxx</code>)</li><li class="ql-align-justify">静态属性和方法：定义在构造函数上的方法(比如<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">Cat.xxx</code>)，不需要实例就可以调用(例如<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">Object.assign()</code>)</li></ul><h4 class="ql-align-justify">1.1 题目一</h4><p class="ql-align-justify">(理解<strong style="color: rgb(248, 57, 41);">私有属性方法</strong>和<strong style="color: rgb(248, 57, 41);">公有属性方法</strong>)</p><p class="ql-align-justify">比如我现在想要封装一个生产出猫，名为<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">Cat</code>的构造函数。</p><ul><li class="ql-align-justify">由于猫的<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">心</code>和<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">胃</code>都是我们肉眼看不见的，所以我把它们设置为私有属性(隐藏起来)</li><li class="ql-align-justify">并且猫的<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">心跳</code>我们也是看不到的，所以我把它设置为私有方法(隐藏起来)</li><li class="ql-align-justify">然后猫的<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">毛色</code>是可以看见的，所以我把它设置为公有属性</li><li class="ql-align-justify">并且猫<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">跳起来</code>这个动作我们是看的到的，所以我把它设置为公有方法</li></ul><pre class="ql-syntax ql-align-justify" spellcheck="false">function Cat (name, color) {
  var heart = '❤️'
  var stomach = '胃'
  var heartbeat = function () {
    console.log(heart + '跳')
  }

  this.name = name
  this.color = color

  this.jump = function () {
    heartbeat() // 能跳起来表明这只猫是活的,心也就能跳
    console.log('我跳起来了~来追我啊')
  }
}
var guaiguai = new Cat('guaiguai', 'white')
console.log(guaiguai)
guaiguai.jump()
</pre><p class="ql-align-justify">上述代码打印出来的应该是：</p><pre class="ql-syntax ql-align-justify" spellcheck="false">Cat{ name: 'guaiguai', color: 'white', jump: function(){} }
❤️跳
我跳起来了~来追我啊
</pre><p class="ql-align-justify">可以看到，我们生产出名字叫做<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">乖乖</code>的小猫咪只有这几个属性能访问到(也就是能被肉眼看到)，为公有属性：</p><ul><li class="ql-align-justify"><code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">name</code></li><li class="ql-align-justify"><code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">color</code></li><li class="ql-align-justify"><code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">jump</code></li></ul><p class="ql-align-justify">而私有属性，是我们看不到的：</p><ul><li class="ql-align-justify"><code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">heart</code></li><li class="ql-align-justify"><code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">somach</code></li><li class="ql-align-justify"><code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">heartbeat</code></li></ul><p class="ql-align-justify">所以如果你想要直接使用它是不能够的：</p><pre class="ql-syntax ql-align-justify" spellcheck="false">// 私有
console.log(guaiguai.heart) // undefined
console.log(guaiguai.stomach) // undefined
guaiguai.heartbeat() // 报错
</pre><p class="ql-align-justify"><strong style="color: rgb(248, 57, 41);">小结：</strong></p><p class="ql-align-justify">很好区分：</p><ul><li class="ql-align-justify">在函数内用<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">var</code>定义的就是私有的</li><li class="ql-align-justify">在函数内用<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">this</code>承接的就是公有</li></ul><p class="ql-align-justify">小猫咪:&nbsp;<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">"凭啥每次都是用我举例子"</code></p><p class="ql-align-justify">霖呆呆:&nbsp;<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">"因为你可爱撒～"</code></p><p class="ql-align-justify">小猫咪:&nbsp;<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">"嘻嘻"</code></p><p class="ql-align-justify"><img src="https://mmbiz.qpic.cn/mmbiz_png/gBEW5LPs1zo0nSrFKAial87mdKSU3qQLZKkyCfHOUJXnoeHtZWtoz4zsYnDF6JcGzrfZLBLsYQMmica5SUib3rWuA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1"></p><p class="ql-align-justify"><br></p><h4 class="ql-align-justify">1.2 题目二</h4><p class="ql-align-justify">(理解<strong style="color: rgb(248, 57, 41);">静态属性方法</strong>和<strong style="color: rgb(248, 57, 41);">公有属性方法</strong>)</p><p class="ql-align-justify">我们现在往刚刚的<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">Cat</code>构造函数中加些东西。</p><ul><li class="ql-align-justify">我们需要对<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">Cat</code>这个构造函数加一个描述，表明它是用来生产猫的，所以我把<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">descript</code>设置为它的静态属性</li><li class="ql-align-justify">由于一听到猫这种动物就觉得它会卖萌，所以我把<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">卖萌</code>这个动作设置为它的静态方法</li><li class="ql-align-justify">由于猫都会用唾液清洁身体，所以我把<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">清洁身体</code>这个动作设置为它的公有方法</li></ul><pre class="ql-syntax ql-align-justify" spellcheck="false">// 这段是旧代码
function Cat (name, color) {
  var heart = '❤️'
  var stomach = '胃'
  var heartbeat = function () {
    console.log(heart + '跳')
  }

  this.name = name
  this.color = color

  this.jump = function () {
    heartbeat() // 能跳起来表明这只猫是活的,心也就能跳
    console.log('我跳起来了~来追我啊')
  }
}
// 这段是新增的代码
Cat.descript = '我这个构造函数是用来生产出一只猫的'
Cat.actingCute = function () {
  console.log('一听到猫我就想到了它会卖萌')
}
Cat.prototype.cleanTheBody = function () {
  console.log('我会用唾液清洁身体')
}
var guaiguai = new Cat('guaiguai', 'white')

console.log(Cat.descript)
Cat.actingCute()
console.log(guaiguai.descript)
guaiguai.cleanTheBody()
</pre><p class="ql-align-justify">上述代码打印出来的应该是：</p><pre class="ql-syntax ql-align-justify" spellcheck="false">'我这个构造函数是用来生产出一只猫的'
'一听到猫我就想到了它会卖萌'
undefined
'我会用唾液清洁身体'
</pre><p class="ql-align-justify">可以看到，我们定义的<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">descript</code>和<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">actingCute</code>是定义在构造函数<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">Cat</code>上的，所以可以直接被<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">Cat</code>调用，为静态属性和方法。</p><p class="ql-align-justify">但是<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">descript</code>和<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">actingCute</code>并不能存在于<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">乖乖</code>这个实例上，<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">descript</code>只是对构造函数<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">Cat</code>的描述，并不是对<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">乖乖</code>的描述，所以打印出<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">undefined</code>。</p><p class="ql-align-justify">不过<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">清洁</code>身体是定义在原型对象<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">prototype</code>中的，属于公有方法(实例方法)，也就是<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">乖乖</code>这个实例可以用它来调用。</p><p class="ql-align-justify">静态属性和方法：</p><ul><li class="ql-align-justify"><code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">descript</code></li><li class="ql-align-justify"><code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">actingCute</code></li></ul><p class="ql-align-justify">实例(公有)属性和方法：</p><ul><li class="ql-align-justify"><code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">name</code></li><li class="ql-align-justify"><code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">color</code></li><li class="ql-align-justify"><code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">jump</code></li><li class="ql-align-justify"><code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">cleanTheBody</code></li></ul><p class="ql-align-justify"><strong style="color: rgb(248, 57, 41);">小结：</strong></p><p class="ql-align-justify">也很好区分：</p><ul><li class="ql-align-justify">在构造函数上也就是使用<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">Cat.xxx</code>定义的是静态属性和方法</li><li class="ql-align-justify">在构造函数内使用<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">this</code>设置，或者设置在构造函数原型对象上比如<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">Cat.prototype.xxx</code>，就是公有属性和方法(实例方法)</li></ul><p class="ql-align-justify">（也有小伙伴可能会有疑问，这个<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">静态属性和方法</code>是有什么用的啊，感觉我们编码的时候并没有用到过啊。<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">Really?</code>&nbsp;哈哈 😄，<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">Promise.all()、Promise.race()、Object.assign()、Array.form()</code>这些不就是吗？）</p><p class="ql-align-justify">（至于<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">实例方法</code>，想想<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">push、shift</code>，它们实际上不是存在于原型对象上的吗？<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">Array.prototype.push</code>）</p><h4 class="ql-align-justify">1.3 题目三</h4><p class="ql-align-justify">（理解<strong style="color: rgb(248, 57, 41);">实例自身的属性</strong>和<strong style="color: rgb(248, 57, 41);">定义在构造函数原型对象中的属性</strong>的区别）</p><p class="ql-align-justify">OK👌，霖呆呆你刚刚既然已经说了使用<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">this.xxx = xxx</code>的方式和使用<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">Cat.prototype.xxx = xxx</code>都是属于实例对象<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">guaiguai</code>上的公有属性，那它们是有什么区别吗？</p><p class="ql-align-justify">来看这道题我们就能理解它们的区别了：</p><pre class="ql-syntax ql-align-justify" spellcheck="false">function Cat (name) {
  this.name = name
}
Cat.prototype.prototypeProp = '我是构造函数原型对象上的属性'
Cat.prototype.cleanTheBody = function () {
  console.log('我会用唾液清洁身体')
}
var guaiguai = new Cat('guaiguai')
console.log(guaiguai)
console.log(guaiguai.name)
console.log(guaiguai.prototypeProp)
guaiguai.cleanTheBody()
</pre><p class="ql-align-justify">这里输出的结果 🤔️？</p><pre class="ql-syntax ql-align-justify" spellcheck="false">Cat {name: "guaiguai"}
'guaiguai'
'我是构造函数原型对象上的属性'
'我会用唾液清洁身体'
</pre><p class="ql-align-justify">看到没，<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">name</code>是使用<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">this.xxx = xxx</code>的形式定义的，它能直接让实例<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">guaiguai</code>就拥有这个属性。</p><p class="ql-align-justify">而<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">prototypeProp 、cleanTheBody</code>毕竟是定义在构造函数原型上的，所以并不能出现在实例<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">guaiguai</code>上，但是<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">guaiguai</code>却能访问和调用它们。</p><p class="ql-align-justify">因此我们得出结论：</p><p class="ql-align-justify"><strong style="color: rgb(248, 57, 41);">定义在构造函数原型对象上的属性和方法虽然不能直接表现在实例对象上，但是实例对象却可以访问或者调用它们</strong></p><h4 class="ql-align-justify">1.4 题目四</h4><p class="ql-align-justify">既然我们已经知道了<strong style="color: rgb(248, 57, 41);">实例自身的属性</strong>和<strong style="color: rgb(248, 57, 41);">定义在构造函数原型对象中的属性</strong>的区别，那么我们一般是如何区分它们的呢？</p><p class="ql-align-justify">来看看这里：</p><pre class="ql-syntax ql-align-justify" spellcheck="false">function Cat (name) {
  this.name = name
}
Cat.prototype.prototypeProp = '我是构造函数原型对象上的属性'
Cat.prototype.cleanTheBody = function () {
  console.log('我会用唾液清洁身体')
}
var guaiguai = new Cat('guaiguai')

for (key in guaiguai) {
  if (guaiguai.hasOwnProperty(key)) {
    console.log('我是自身属性', key)
  } else {
    console.log('我不是自身属性', key)
  }
}
console.log('-分隔符-')
console.log(Object.keys(guaiguai))
console.log(Object.getOwnPropertyNames(guaiguai))
</pre><p class="ql-align-justify">这道题中，我分别用了三种方式来获取实例对象<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">guaiguai</code>上的属性名：</p><ul><li class="ql-align-justify"><code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">for...in...</code></li><li class="ql-align-justify"><code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">Object.keys()</code></li><li class="ql-align-justify"><code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">Object.getOwnPropertyNames()</code></li></ul><p class="ql-align-justify">输出的结果为：</p><pre class="ql-syntax ql-align-justify" spellcheck="false">'我是自身属性 name'
'我不是自身属性 prototypeProp'
'我不是自身属性 cleanTheBody'
'-分隔符-'
["name"]
["name"]
</pre><p class="ql-align-justify">由此可以得出：</p><ul><li class="ql-align-justify">使用<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">for...in...</code>能获取到实例对象自身的属性和原型链上的属性</li><li class="ql-align-justify">使用<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">Object.keys()</code>和<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">Object.getOwnPropertyNames()</code>只能获取实例对象自身的属性</li><li class="ql-align-justify">可以通过<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">.hasOwnProperty()</code>方法传入属性名来判断一个属性是不是实例自身的属性</li></ul><p class="ql-align-justify">（上面👆的说法其实并不太严谨，因为要建立在可枚举属性的前提下(属性的<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">enumerable</code>为<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">true</code>)，不过这边我不发散下去了...）</p><h4 class="ql-align-justify">1.5 题目五</h4><p class="ql-align-justify">下面让我们来做道题，看看你到底有没有掌握上面的知识点呢 😁。</p><pre class="ql-syntax ql-align-justify" spellcheck="false">function Person (name, sex) {
  this.name = name
  this.sex = sex
  var evil = '我很邪恶'
  var pickNose = function () {
    console.log('我会扣鼻子但不让你看见')
  }
  this.drawing = function (type) {
    console.log('我要画一幅' + type)
  }
}
Person.fight = function () {
  console.log('打架')
}
Person.prototype.wc = function () {
  console.log('我是个人我会wc')
}
var p1 = new Person('lindaidai', 'boy')
console.log(p1.name)
console.log(p1.evil)
p1.drawing('国画')
p1.pickNose()
p1.fight()
p1.wc()
Person.fight()
Person.wc()
console.log(Person.sex)
</pre><p class="ql-align-justify">答案：</p><pre class="ql-syntax ql-align-justify" spellcheck="false">'lindaidai'
undefined
'我要画一幅国画'
Uncaught TypeError: p1.pickNose is not a function
Uncaught TypeError: p1.fight is not a function
'我是个人我会wc'
'打架'
Uncaught TypeError: Person.wc is not a function
undefined
</pre><p class="ql-align-justify">解析：</p><ul><li class="ql-align-justify"><code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">name</code>为公有属性，实例访问它打印出<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">'lindaidai'</code></li><li class="ql-align-justify"><code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">evil</code>为私有属性，实例访问它打印出<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">'undefined'</code></li><li class="ql-align-justify"><code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">drawing</code>是共有(实例)方法，实例调用它打印出<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">'我要画一幅国画'</code></li><li class="ql-align-justify"><code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">pickNose</code>是私有方法，实例调用它会报错，因为它并不存在于实例上</li><li class="ql-align-justify"><code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">fight</code>是静态方法，实例调用它报错，因为它并不存在于实例上</li><li class="ql-align-justify"><code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">wc</code>存在于构造函数的原型对象中，使用实例调用它打印出<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">'我是个我会wc'</code></li><li class="ql-align-justify"><code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">fight</code>存在于构造函数上，使用构造函数调用它打印出<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">'打架'</code></li><li class="ql-align-justify"><code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">wc</code>存在于构造函数的原型对象中，并不存在于构造函数中，所以报错</li><li class="ql-align-justify"><code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">sex</code>为公有(实例)属性，并不存在于构造函数上，使用构造函数访问它为<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">undefined</code></li></ul><p class="ql-align-justify">这里大家可能会有一个疑惑点了，为什么最后一个<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">Person.sex</code>也会是<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">undefined</code>呢？</p><p class="ql-align-justify">我明明已经这样写了：</p><pre class="ql-syntax ql-align-justify" spellcheck="false">function Person (sex) {
	this.sex = sex
}
</pre><p class="ql-align-justify">看起来<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">sex</code>是定义在<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">Person</code>里的呀。</p><p class="ql-align-justify">注意了，<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">this.sex</code>表示的是给使用构造函数创建的实例上增加属性<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">sex</code>，而不是给构造函数本身增加(只有<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">Person.sex</code>才是给构造函数上增加属性)。</p><h4 class="ql-align-justify">1.6 题目六</h4><p class="ql-align-justify">如果我的构造函数和构造函数原型对象上存在相同名称的属性咋办呢 🤔️ ？</p><pre class="ql-syntax ql-align-justify" spellcheck="false">function Cat () {
  this.color = 'white'
  this.getColor = function () {
    console.log(this.color)
  }
}
Cat.prototype.color = 'black'
var cat = new Cat()
cat.getColor()
</pre><p class="ql-align-justify">这里的执行结果为：</p><pre class="ql-syntax ql-align-justify" spellcheck="false">'white'
</pre><p class="ql-align-justify">其实这个很好理解，你原型对象上虽然有一个名叫<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">color</code>的属性，但是我实例对象自己就也有一个啊，那我为什么要用你的呢？只有我自己没有，我才会到你那里去拿。</p><p class="ql-align-justify">所以这也就引出了另一个经常听到的概念：</p><p class="ql-align-justify"><strong style="color: rgb(248, 57, 41);">当访问一个对象的属性 / 方法时，它不仅仅在该对象上查找，还会查找该对象的原型，以及该对象的原型的原型，一层一层向上查找，直到找到一个名字匹配的属性 / 方法或到达原型链的末尾（</strong><code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);"><strong>null</strong></code><strong style="color: rgb(248, 57, 41);">）。</strong></p><p class="ql-align-justify">也就是大名鼎鼎的<strong style="color: rgb(248, 57, 41);">原型链查找</strong>。</p><p class="ql-align-justify">咱要是没理解没关系哈，一起来看下面一个例子。</p><h4 class="ql-align-justify">1.7 题目七</h4><p class="ql-align-justify">现在我在<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">Cat</code>的原型对象上，还有它原型对象的原型对象上都定义一个叫做<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">color</code>的属性。</p><p class="ql-align-justify">(原型对象本质也是个对象，所以它的<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">__proto__</code>也就是<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">Object.prototype</code>)</p><pre class="ql-syntax ql-align-justify" spellcheck="false">function Cat () {
  this.color = 'white'
  this.getColor = function () {
    console.log(this.color)
  }
}
Cat.prototype.color = 'black'
Object.prototype.color = 'yellow'
Object.prototype.feature = 'cute'
var cat = new Cat()

cat.getColor()
console.log(cat)
console.log(cat.feature)
</pre><p class="ql-align-justify">然后让我们来看看结果：</p><pre class="ql-syntax ql-align-justify" spellcheck="false">'white'
Cat {color: "white", getColor: ƒ}
'cute'
</pre><p class="ql-align-justify">看到了不。</p><p class="ql-align-justify"><code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">color</code>这个属性还是以它自身的<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">white</code>为主，但是<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">feature</code>这个属性没在实例<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">cat</code>上吧，所以它就会向上层一层查找，结果在<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">Object.prototype</code>中找到了，因此打印出<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">cute</code>。</p><p class="ql-align-justify">整个过程就是这样：</p><p class="ql-align-justify"><img src="https://mmbiz.qpic.cn/mmbiz_png/gBEW5LPs1zo0nSrFKAial87mdKSU3qQLZyl2MpIzfyU22XNv1G1YaEyeCCtCXvnwbIaSheJOrESibVHeH52xVlgg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1"></p><p class="ql-align-justify">(偷个懒，盗个图😂，图片来源https://muyiy.cn/idea/)</p><h4 class="ql-align-justify">1.8 题目八</h4><p class="ql-align-justify"><code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">"等会等会，让我缓一下"</code></p><p class="ql-align-justify"><code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">"wc，我突然就想明白了很多事情！"</code></p><p class="ql-align-justify">比如下面这种写法：</p><pre class="ql-syntax ql-align-justify" spellcheck="false">var obj = { name: 'obj' }
console.log(obj.toString())
console.log(obj.hasOwnProperty('name'))
console.log(Object.prototype)
</pre><p class="ql-align-justify">为什么我的<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">obj</code>中明明就没有<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">toString()、hasOwnProperty()</code>方法，但是我却可以调用它。</p><p class="ql-align-justify">现在我知道了，原来<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">obj</code>本质是个<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">Object</code>类型。</p><p class="ql-align-justify">使用<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">var obj = { name: 'obj' }</code>就相当于是调用了<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">new Object</code>：</p><pre class="ql-syntax ql-align-justify" spellcheck="false">var obj = newObject({ 'name': 'obj' })
</pre><p class="ql-align-justify">这样的话，我当然就可以使用<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">Object.prototype</code>上的方法啦！</p><p class="ql-align-justify">执行结果为：</p><p class="ql-align-justify"><img src="https://mmbiz.qpic.cn/mmbiz_png/gBEW5LPs1zo0nSrFKAial87mdKSU3qQLZshHdOQbZqRMHictmVul4kYR1CmZtEAEibo5BtctrcWECetUXiawO6Giaaw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1"></p><p class="ql-align-justify">(<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">obj.toString()</code>这里的结果为<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">[object Object]</code>应该都知道是什么原因吧？)</p><h4 class="ql-align-justify">总结-构造函数</h4><p class="ql-align-justify">现在再来回头看看那句话：</p><p class="ql-align-justify"><strong style="color: rgb(248, 57, 41);">把客观事物封装成抽象的类，隐藏属性和方法，仅对外公开接口</strong></p><p class="ql-align-justify">是不是好理解多了呢？</p><p class="ql-align-justify">然后让我们对<strong style="color: rgb(248, 57, 41);">构造函数配合原型对象</strong>封装来做一个总结吧：</p><p class="ql-align-justify"><strong style="color: rgb(248, 57, 41);">(一) 私有属性、公有属性、静态属性概念：</strong></p><ul><li class="ql-align-justify">私有属性和方法：只能在构造函数内访问不能被外部所访问(在构造函数内使用<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">var</code>声明的属性)，见题<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">1.1</code></li><li class="ql-align-justify">公有属性和方法(或实例方法)：对象外可以访问到对象内的属性和方法(在构造函数内使用<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">this</code>设置，或者设置在构造函数原型对象上比如<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">Cat.prototype.xxx</code>)，见题<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">1.2</code></li><li class="ql-align-justify">静态属性和方法：定义在构造函数上的方法(比如<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">Cat.xxx</code>)，不需要实例就可以调用(例如<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">Object.assign()</code>)</li></ul><p class="ql-align-justify"><strong style="color: rgb(248, 57, 41);">(二) 实例对象上的属性和构造函数原型上的属性：</strong></p><ul><li class="ql-align-justify">定义在<strong style="color: rgb(248, 57, 41);">构造函数原型对象上的属性和方法</strong>虽然不能直接表现在实例对象上，但是实例对象却可以访问或者调用它们。(见题<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">1.3</code>)</li><li class="ql-align-justify">当访问一个对象的属性 / 方法时，它不仅仅在该对象上查找，还会查找该对象的原型，以及该对象的原型的原型，一层一层向上查找，直到找到一个名字匹配的属性 / 方法或到达原型链的末尾（<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">null</code>）。(见题<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">1.7</code>)</li></ul><p class="ql-align-justify"><strong style="color: rgb(248, 57, 41);">(三) 遍历实例对象属性的三种方法:</strong></p><ul><li class="ql-align-justify">使用<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">for...in...</code>能获取到实例对象自身的属性和原型链上的属性</li><li class="ql-align-justify">使用<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">Object.keys()</code>和<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">Object.getOwnPropertyNames()</code>只能获取实例对象自身的属性</li><li class="ql-align-justify">可以通过<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">.hasOwnProperty()</code>方法传入属性名来判断一个属性是不是实例自身的属性</li></ul><h3 class="ql-align-justify"><span style="color: rgb(165, 213, 93);">2. ES6之后的封装</span></h3><p class="ql-align-justify">在<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">ES6</code>之后，新增了<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">class</code>&nbsp;这个关键字。</p><p class="ql-align-justify">它可以用来代替构造函数，达到创建“一类实例”的效果。</p><p class="ql-align-justify">并且类的数据类型就是<strong style="color: rgb(248, 57, 41);">函数</strong>，所以用法上和构造函数很像，直接用<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">new</code>命令来配合它创建一个实例。</p><p class="ql-align-justify">还有一件事你可能不知道吧，那就是，<strong style="color: rgb(248, 57, 41);">类的所有方法都定义在类的prototype属性上面</strong>。</p><p class="ql-align-justify">例如：</p><pre class="ql-syntax ql-align-justify" spellcheck="false">class Cat {
    constructor() {}
    toString () {}
    toValue () {}
}
// 等同于
function Cat () {}
Cat.prototype = {
    constructor() {}
    toString () {}
    toValue () {}
}
</pre><p class="ql-align-justify">这个可以看下面👇的题目<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">2.2</code>来理解它。</p><h4 class="ql-align-justify">2.1 题目一</h4><p class="ql-align-justify">现在我们将<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">1.1</code>的题目换成<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">class</code>版本的来看看。</p><pre class="ql-syntax ql-align-justify" spellcheck="false">class Cat {
  constructor (name, color) {
    var heart = '❤️'
    var stomach = '胃'
    var heartbeat = function () {
      console.log(heart + '跳')
    }

    this.name = name
    this.color = color
    this.jump = function () {
      heartbeat()
     	console.log('我跳起来了~来追我啊')
    }
  }
}
var guaiguai = new Cat('guaiguai', 'white')
console.log(guaiguai)
guaiguai.jump()
</pre><p class="ql-align-justify">其实你会发现，当你使用<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">class</code>的时候，它会默认调用<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">constructor</code>这个函数，来接收一些参数，并构造出一个新的实例对象(<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">this</code>)并将它返回，因此它被称为<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">constructor</code>构造方法(函数)。</p><p class="ql-align-justify">(另外，其实如果你的<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">class</code>没有定义<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">constructor</code>，也会隐式生成一个<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">constructor</code>方法)</p><p class="ql-align-justify">可以看到，经过用<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">class</code>改造后的<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">Cat</code></p><p class="ql-align-justify">公有(实例)属性和方法：</p><ul><li class="ql-align-justify"><code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">name</code></li><li class="ql-align-justify"><code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">color</code></li><li class="ql-align-justify"><code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">jump</code></li></ul><p class="ql-align-justify">而对于私有属性，个人感觉上述的<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">heart</code>不应该叫做私有属性，它只不过被局限于<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">constructor</code>这个构造函数中，是这个作用域下的变量而已。</p><p class="ql-align-justify">执行结果：</p><pre class="ql-syntax ql-align-justify" spellcheck="false">Cat{ name: 'guaiguai', color: 'white', jump: function () {} }
❤️跳
'我跳起来了~来追我啊'
</pre><h4 class="ql-align-justify">2.2 题目二</h4><p class="ql-align-justify">（弄懂在类中定义属性或方法的几种方式）</p><pre class="ql-syntax ql-align-justify" spellcheck="false">class Cat {
  constructor () {
    var heart = '❤️'
    this.name = 'guaiguai'
    this.jump = function () {}
  }
  color = 'white'
  cleanTheBody = function () {
    console.log('我会用唾液清洁身体')
  }
  hideTheShit () {
    console.log('我在臭臭完之后会把它藏起来')
  }
}
var guaiguai = new Cat()
console.log(guaiguai)
console.log(Object.keys(guaiguai))
guaiguai.cleanTheBody()
guaiguai.hideTheShit()
</pre><p class="ql-align-justify">请仔细看看这道题，在这里面我用了四种不同的方式来定义一些属性。</p><ol><li class="ql-align-justify">在<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">constructor</code>中<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">var</code>一个变量，它只存在于<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">constructor</code>这个构造函数中</li><li class="ql-align-justify">在<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">constructor</code>中使用<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">this</code>定义的属性和方法会被定义到实例上</li><li class="ql-align-justify">在<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">class</code>中使用<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">=</code>来定义一个属性和方法，效果与第二点相同，会被定义到实例上</li><li class="ql-align-justify">在<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">class</code>中直接定义一个方法，会被添加到<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">原型对象prototype</code>上</li></ol><p class="ql-align-justify">至此，这道题的答案为：</p><pre class="ql-syntax ql-align-justify" spellcheck="false">Cat {color: "white", name: "guaiguai", cleanTheBody: ƒ, jump: ƒ}
["color", "cleanTheBody", "name", "jump"]
'我会用唾液清洁身体'
'我在臭臭完之后会把它藏起来'
</pre><p class="ql-align-justify">解析：</p><ul><li class="ql-align-justify"><code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">heart</code>只能在<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">constructor</code>函数中使用，因此不会出现在实例上。</li><li class="ql-align-justify"><code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">name、jump、color、cleanTheBody</code>满足于上面👆说到的第二点和第三点</li><li class="ql-align-justify"><code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">hideTheShit</code>是在类里直接定义的，满足于上面👆说的第四点，因此它不会被<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">Object.keys()</code>获取到。</li><li class="ql-align-justify"><code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">hideTheShit</code>虽然是在原型对象中，但是也还是能被实例对象所调用，因此最后一段代码也会被执行<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">'我在臭臭完之后会把它藏起来'</code></li></ul><p class="ql-align-justify"><img src="https://mmbiz.qpic.cn/mmbiz_jpg/gBEW5LPs1zo0nSrFKAial87mdKSU3qQLZUgziaeHlr8d9pKI81yN5ly4HD4IKX7YFyIzZiccuicMyzpIVBDIyGN7uA/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1"></p><p class="ql-align-justify">这四种定义的方式已经介绍完了 😁，相信大家比较迷惑的一点就是以下这两种方式的定义吧：</p><pre class="ql-syntax ql-align-justify" spellcheck="false">class Cat {
    cleanTheBody = function () {}
    hideTheShit () {}
}
</pre><p class="ql-align-justify">看起来都是定义一个函数呀，为什么第一个就可以在实例对象中，而第二个是在原型对象中呢 🤔️ ？</p><p class="ql-align-justify">其实不需要特意的去记住它，你只需要知道：<strong style="color: rgb(248, 57, 41);">在类的所有方法都定义在类的prototype属性上面</strong>。</p><p class="ql-align-justify">这里的<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">cleanTheBody</code>你可以理解为它和<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">color</code>一样只是一个普通的变量，只不过这个变量是个函数，所以它并不算是定义在类上的函数，因此不会存在于原型对象上。</p><p class="ql-align-justify">而<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">hideTheShit</code>是实实在在的定义在类上的方法，所以它和<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">constructor</code>方法一样，都是在类的原型对象上。</p><p class="ql-align-justify">转化为伪代码就是：</p><pre class="ql-syntax ql-align-justify" spellcheck="false">class Cat {
    constructor() {}
    hideTheShit () {}
}
// 等同于
function Cat () {}
Cat.prototype = {
    constructor() {}
    hideTheShit () {}
}
</pre><h4 class="ql-align-justify">2.3 题目三</h4><p class="ql-align-justify">(在<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">class</code>定义静态属性和方法)</p><p class="ql-align-justify">前面我们给<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">Cat</code>定义静态属性和方法是采用这种方式，<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">Cat.xxx</code>：</p><pre class="ql-syntax ql-align-justify" spellcheck="false">function Cat () {...}
Cat.descript = '我这个构造函数是用来生产出一只猫的'
Cat.actingCute = function () {
  console.log('一听到猫我就想到了它会卖萌')
}
</pre><p class="ql-align-justify">在<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">class</code>中你也可以使用<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">Cat.xxx</code>这种方式定义，因为前面说过了，<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">class</code>本质也是个对象。</p><p class="ql-align-justify">但除此之外，你还可以使用<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">static</code>标识符表示它是一个静态的属性或者方法：</p><pre class="ql-syntax ql-align-justify" spellcheck="false">class Cat {
  static descript = '我这个类是用来生产出一只猫的'
  static actingCute () {
    console.log('一听到猫我就想到了它会卖萌')
  }
	// static actingCute = function () {} // 这种写法也是设置静态的方法
}
</pre><p class="ql-align-justify">OK👌，现在让我们来做做下面这道题吧 😊：</p><pre class="ql-syntax ql-align-justify" spellcheck="false">class Cat {
  constructor (name, color) {
    var heart = '❤️'
    var stomach = '胃'
    var heartbeat = function () {
      console.log(heart + '跳')
    }
    this.name = name
    this.color = color
    heartbeat()
    this.jump = function () {
      console.log(this)
      console.log('我跳起来了~来追我啊')
    }
  }
  cleanTheBody = function () {
    console.log('我会用唾液清洁身体')
  }
  static descript = '我这个类是用来生产出一只猫的'
  static actingCute () {
    console.log(this)
    console.log('一听到猫我就想到了它会卖萌')
  }
}
Cat.staticName = 'staticName'
var guaiguai = new Cat('guaiguai', 'white')

console.log(guaiguai)
guaiguai.jump()
guaiguai.cleanTheBody()
console.log(guaiguai.descript)
guaiguai.actingCute()

Cat.actingCute()
console.log(Cat.descript)
console.log(Cat.staticName)
</pre><p class="ql-align-justify">结果：</p><pre class="ql-syntax ql-align-justify" spellcheck="false">❤️跳
Cat{ name: 'guaiguai', color: 'white', jump: function(){}, cleanTheBody: function(){} }
Cat{ name: 'guaiguai', color: 'white', jump: function(){}, cleanTheBody: function(){} }
'我跳起来了~来追我啊'
'我会用唾液清洁身体'
undefined
Uncaught TypeError: guaiguai.actingCute is not a function

class Cat{...}
'一听到猫我就想到了它会卖萌'
'我这个类是用来生产出一只猫的'
'staticName'
</pre><p class="ql-align-justify">结果分析：</p><ul><li class="ql-align-justify">首先在构造<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">guaiguai</code>这个对象的时候会执行<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">heartbeat</code>方法，打印出<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">❤️跳</code></li><li class="ql-align-justify">其次打印出的<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">guaiguai</code>它只会拥有<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">class</code>中定义的实例属性和方法，所以并不会有<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">descript</code>和<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">actingCute</code></li><li class="ql-align-justify"><code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">jump</code>中的<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">this</code>指向的是实例对象<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">guaiguai</code>，并且执行了<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">'我跳起来了~来追我啊'</code></li><li class="ql-align-justify">直接定义在<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">class</code>中的属性或者方法就相当于是定义在<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">Cat.prototype</code>上，所以也属于实例方法，<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">cleanThebody</code>会执行打印出<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">'我会用唾液清洁身体'</code></li><li class="ql-align-justify">使用了<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">static</code>定义的属性和方法为静态属性和方法，并不存在于实例上，所以打印出<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">undefined</code>和报错</li><li class="ql-align-justify"><code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">actingCute</code>使用了<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">static</code>修饰符，所以它是静态方法，存在于<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">Cat</code>这个类上，因此它里面的<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">this</code>指向这个类，并且执行了<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">'一听到猫我就想到了它会卖萌'</code></li><li class="ql-align-justify"><code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">descript</code>使用了<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">static</code>修饰符，所以它是静态属性，打印出<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">'我这个类是用来生产出一只猫的'</code></li><li class="ql-align-justify"><code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">Cat.staticName = 'staticName'</code>就相当于定义了一个静态属性，所以打印出<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">staticName</code></li></ul><h4 class="ql-align-justify">2.4 题目四</h4><p class="ql-align-justify">我们再来看看这道题，友情提示，这是个坑 🤮...</p><pre class="ql-syntax ql-align-justify" spellcheck="false">var a = new A()
function A () {}
console.log(a)

var b = new B()
class B {}
console.log(a)
</pre><p class="ql-align-justify">你开始的预想是不是：</p><pre class="ql-syntax ql-align-justify" spellcheck="false">A{}
B{}
</pre><p class="ql-align-justify">😁，结果却发现报错了：</p><pre class="ql-syntax ql-align-justify" spellcheck="false">A {}
Uncaught ReferenceError: Cannot access 'B' before initialization
</pre><p class="ql-align-justify">那是因为，函数<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">A</code>是会被提升至作用域的最顶层，所以可以在定义函数<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">A</code>之前使用<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">new A()</code></p><p class="ql-align-justify"><strong style="color: rgb(248, 57, 41);">但是类却不存在这种提升机制</strong>，所以当你执行<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">new B()</code>的时候它就会告诉你在<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">B</code>没有初始化之前不能使用它。</p><p class="ql-align-justify">尽管我们知道，<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">class</code>它的本质也是一个函数：</p><pre class="ql-syntax ql-align-justify" spellcheck="false">console.log(typeof B) // function
</pre><h4 class="ql-align-justify">2.5 题目五</h4><p class="ql-align-justify">坑二 🤮...</p><pre class="ql-syntax ql-align-justify" spellcheck="false">class Cat {
  constructor () {
    this.name = 'guaiguai'
    var type = 'constructor'
  }
  type = 'class'
  getType = function () {
    console.log(this.type)
    console.log(type)
  }
}
var type = 'window'
var guaiguai = new Cat()
guaiguai.getType()
</pre><p class="ql-align-justify">这里的执行结果是什么呢？</p><p class="ql-align-justify">主要是考察了你对作用域以及<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">class</code>的理解。</p><p class="ql-align-justify">答案为：</p><pre class="ql-syntax ql-align-justify" spellcheck="false">'class'
'window'
</pre><p class="ql-align-justify">解析：</p><ul><li class="ql-align-justify">调用<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">getType</code>函数的是<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">guaiguai</code>，所以里面的<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">this</code>指向了<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">guaiguai</code>，而<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">guaiguai</code>上的<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">type</code>为<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">class</code></li><li class="ql-align-justify">当要打印出<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">type</code>的时候，发现<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">getType</code>函数中并没有这个变量，所以就向外层查找，找到了<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">window</code>中存在这个变量，因此打印出<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">window</code>。(<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">var type = 'constructor'</code>是函数<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">constructor</code>中的变量)</li></ul><h4 class="ql-align-justify">2.6 题目六</h4><p class="ql-align-justify">既然做到了函数类型的题目，那怎么能不想到箭头函数呢？嘿嘿 。</p><p class="ql-align-justify">阴笑～</p><p class="ql-align-justify">让我们将<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">2.5</code>中的<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">getType</code>函数换成箭头函数看看？</p><pre class="ql-syntax ql-align-justify" spellcheck="false">class Cat {
  constructor () {
    this.name = 'guaiguai'
    var type = 'constructor'
  }
  type = 'class'
  getType = () =&gt; {
    console.log(this.type)
    console.log(type)
  }
}
var type = 'window'
var guaiguai = new Cat()
guaiguai.getType()
console.log(guaiguai)
</pre><p class="ql-align-justify">现在调用<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">guaiguai.getType()</code>你觉得会是啥？</p><p class="ql-align-justify"><code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">"既然箭头函数内的this是由外层作用域决定的，那这里外层作用域是window，当然this.type就是'window'咯"</code></p><p class="ql-align-justify">咦～</p><p class="ql-align-justify">还记得我之前说过的，<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">class</code>的本质是个函数吗？所以你碰到<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">class</code>内有箭头函数的题目，把它当成构造函数创建对象来处理就可以了。</p><p class="ql-align-justify">在构造函数中如果使用了箭头函数的话，<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">this</code>指向的就是这个实例对象。</p><p class="ql-align-justify">因此将<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">class</code>转化为构造函数的话，伪代码为：</p><pre class="ql-syntax ql-align-justify" spellcheck="false">function Cat () {
  this.type = 'class'
  this.getType = () =&gt; {
    console.log(this.type)
    console.log(type)
  }
}
Cat.prototype.constructor = function () {
  this.name = 'guaiguai'
  var type = 'constructor'
}
var type = 'window'
var guaiguai = new Cat()
guaiguai.constructor()
guaiguai.getType()
console.log(guaiguai)
</pre><p class="ql-align-justify">别的都好理解，这里为啥，<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">constructor</code>要放在原型对象中，并且要在<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">var guaiguai = new Cat()</code>下面再调用它呢？</p><p class="ql-align-justify">嘻嘻，还记得在<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">2.2</code>中我们就说过了吗，任何放在类上的方法都相当于写在原型对象上，并且在使用类的时候，会隐式执行<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">constructor</code>函数。这两段代码就是为了模拟这个操作。</p><p class="ql-align-justify">这样的话，上面👆两个题目的结果都是：</p><pre class="ql-syntax ql-align-justify" spellcheck="false">'class'
'window'
Cat {type: "class", name: "guaiguai", getType: ƒ}
</pre><p class="ql-align-justify"><code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">哇～</code></p><p class="ql-align-justify"><code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">有点意思哈～</code></p><p class="ql-align-justify"><code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">class还能这样玩？😁</code></p><p class="ql-align-justify"><code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">霖呆呆你....你臭不要脸</code></p><p class="ql-align-justify">不过上面对于箭头函数还有不理解的小伙伴可以查看这篇</p><p class="ql-align-justify">《【建议👍】再来40道this面试题酸爽继续(1.2w字用手整理)》</p><p class="ql-align-justify">文章中的<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">7.4</code>题，里面介绍了<strong style="color: rgb(248, 57, 41);">构造函数对象中普通函数和箭头函数的区别</strong>。</p><p class="ql-align-justify"><img src="https://mmbiz.qpic.cn/mmbiz_png/gBEW5LPs1zo0nSrFKAial87mdKSU3qQLZ9FV0TDsVIVo7GldVcGiaUrauqaxYECD08ibTbU8k4mDLjJ8v7hK7jeBQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1"></p><p class="ql-align-justify"><br></p><h4 class="ql-align-justify">2.7 题目七</h4><p class="ql-align-justify">如果在<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">class</code>中存在两个相同的属性或者方法会怎么样呢 🤔️？</p><pre class="ql-syntax ql-align-justify" spellcheck="false">class Cat {
  constructor () {
    this.name = 'cat1'
  }
  name = 'cat2'
  getName = function  () {
    console.log(this.name)
  }
}
var cat = new Cat()
cat.getName()
</pre><p class="ql-align-justify">这道题中，我们调用<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">getName</code>方法，打印出的会是：</p><pre class="ql-syntax ql-align-justify" spellcheck="false">'cat1'
</pre><p class="ql-align-justify">所以可以看出<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">constructor</code>中定义的相同名称的属性和方法会覆盖在<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">class</code>里定义的。</p><h4 class="ql-align-justify">2.8 题目八</h4><p class="ql-align-justify">那么，原型对象中相同名称的属性和方法呢？</p><pre class="ql-syntax ql-align-justify" spellcheck="false">class Cat {
  constructor () {
    this.name = 'cat1'
  }
  name = 'cat2'
  getName = function  () {
    console.log(this.name)
  }
}
Cat.prototype.name = 'cat3'
var cat = new Cat()
cat.getName()
</pre><p class="ql-align-justify">答案：</p><pre class="ql-syntax ql-align-justify" spellcheck="false">'cat1'
</pre><p class="ql-align-justify">没错，还是以<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">constructor</code>中的为准。这里和构造函数中同名属性的处理方式是一样的，可以看上面👆的<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">1.7</code>题。</p><h4 class="ql-align-justify">2.9 题目九</h4><p class="ql-align-justify">好吧 😅，现在可以加大难度了：</p><pre class="ql-syntax ql-align-justify" spellcheck="false">class Cat {
  constructor () {
    this.name = 'guaiguai'
    var type = 'constructor'
    this.getType = () =&gt; {
      console.log(this.type)
      console.log(type)
    }
  }
  type = 'class'
  getType = () =&gt; {
    console.log(this.type)
    console.log(type)
  }
}
var type = 'window'
var guaiguai = new Cat()
guaiguai.getType()
console.log(guaiguai)
</pre><p class="ql-align-justify">首先我们很清楚，如果<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">type</code>打印出的是<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">window</code>那就表示使用的是第二个<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">getType</code>，否则表示用的是第一个<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">getType</code>。</p><p class="ql-align-justify">那么根据题<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">2.7</code>，我们可以看出，第一个<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">getType</code>是会覆盖第二个的，所以执行结果为：</p><pre class="ql-syntax ql-align-justify" spellcheck="false">'class'
'constructor'
Cat {type: "class", name: "guaiguai", getType: ƒ}
</pre><h4 class="ql-align-justify">总结-class</h4><p class="ql-align-justify">来吧，对<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">class</code>实现封装也来做个总结呗：</p><p class="ql-align-justify"><strong style="color: rgb(248, 57, 41);">(一) class的基本概念：</strong></p><ul><li class="ql-align-justify">当你使用<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">class</code>的时候，它会默认调用<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">constructor</code>这个函数，来接收一些参数，并构造出一个新的实例对象(<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">this</code>)并将它返回。</li><li class="ql-align-justify">如果你的<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">class</code>没有定义<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">constructor</code>，也会隐式生成一个<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">constructor</code>方法</li></ul><p class="ql-align-justify"><strong style="color: rgb(248, 57, 41);">(二) class中几种定义属性的区别：</strong>：</p><ul><li class="ql-align-justify">在<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">constructor</code>中<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">var</code>一个变量，它只存在于<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">constructor</code>这个构造函数中</li><li class="ql-align-justify">在<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">constructor</code>中使用<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">this</code>定义的属性和方法会被定义到实例上</li><li class="ql-align-justify">在<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">class</code>中使用<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">=</code>来定义一个属性和方法，效果与第二点相同，会被定义到实例上</li><li class="ql-align-justify">在<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">class</code>中直接定义一个方法，会被添加到<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">原型对象prototype</code>上</li><li class="ql-align-justify">在<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">class</code>中使用了<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">static</code>修饰符定义的属性和方法被认为是静态的，被添加到类本身，不会添加到实例上</li></ul><p class="ql-align-justify"><strong style="color: rgb(248, 57, 41);">(三) other:</strong></p><ul><li class="ql-align-justify"><code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">class</code>本质虽然是个函数，但是并不会像函数一样提升至作用域最顶层</li><li class="ql-align-justify">如遇<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">class</code>中箭头函数等题目请参照构造函数来处理</li><li class="ql-align-justify">使用<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">class</code>生成的实例对象，也会有沿着原型链查找的功能</li></ul><h2 class="ql-align-justify"><strong>后语</strong></h2><p class="ql-align-justify">知识无价，支持原创。</p><p class="ql-align-justify">参考文章：</p><ul><li class="ql-align-justify">《前端瓶子君-JS 继承的 六 种实现方式》</li><li class="ql-align-justify">《Js三大特性--封装、继承以及多态》</li><li class="ql-align-justify">《浅谈JavaScript的面向对象和它的封装、继承、多态》</li></ul><p class="ql-align-justify">你盼世界，我盼望你无<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">bug</code>。这篇文章就介绍到这里，让我们先打好面向对象的基础，才能挑战后面的<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">魔鬼</code>题目 😄。(才能继承家产，哈哈哈)</p><p class="ql-align-justify"><img src="https://mmbiz.qpic.cn/mmbiz_png/gBEW5LPs1zo0nSrFKAial87mdKSU3qQLZKKp5B2ey78tiaRrfJgdE111YLGdMZOE8C1rw7WO89OaDFz9jcaX6N2A/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1"></p><p class="ql-align-justify">系列中的<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">继承</code>和<code style="color: rgb(255, 93, 108); background-color: rgba(27, 31, 35, 0.05);">多态</code>霖呆呆也会在近几天给更出来，请期待一小下吧 😄。</p><p class="ql-align-justify"><br></p><p class="ql-align-justify">&nbsp;相关推荐</p><p class="ql-align-justify"><a href="http://mp.weixin.qq.com/s?__biz=MjM5NTQ4ODc5MA==&amp;mid=2247484749&amp;idx=5&amp;sn=91da0927ceffff9a976de7ec9d698fd6&amp;chksm=a6f6f03491817922ddc1b23307b7c3f0c3ce293875bf4fd519f3235d9fd275b722cfa958ae99&amp;scene=21#wechat_redirect" target="_blank" style="color: var(--weui-LINK);">前端工程师必须掌握的几个JavaScript设计模式及场景应用</a></p><p class="ql-align-justify"><a href="http://mp.weixin.qq.com/s?__biz=MjM5NTQ4ODc5MA==&amp;mid=2247484735&amp;idx=5&amp;sn=f3a0a53c46c15634003d82b17dbedddf&amp;chksm=a6f6f046918179509e4c1c8e94051fd974a2ee8ac1f7d157362461a806774e7f04cc85e48f45&amp;scene=21#wechat_redirect" target="_blank" style="color: var(--weui-LINK);">【JS进阶深挖】完全弄懂数据类型转换(下)</a></p><p class="ql-align-justify"><a href="http://mp.weixin.qq.com/s?__biz=MjM5NTQ4ODc5MA==&amp;mid=2247484719&amp;idx=5&amp;sn=9f08b5b48bd254ccea9ad3cd5118feaa&amp;chksm=a6f6f05691817940830a33deff27b0c4eb77c1a7c75b95ffa8bdde9403cdf52ac58b044b3e43&amp;scene=21#wechat_redirect" target="_blank" style="color: var(--weui-LINK);">绝大部分的开源项目都投入TypeScript了！你呢？</a></p><p class="ql-align-justify"><a href="http://mp.weixin.qq.com/s?__biz=MjM5NTQ4ODc5MA==&amp;mid=2247484679&amp;idx=3&amp;sn=65959bbfeec07f5843f2eb5031586f08&amp;chksm=a6f6f07e918179683707aa77c49b65b7709f6160b9b638e5e5a21e5b0afac4332cdc07deef89&amp;scene=21#wechat_redirect" target="_blank" style="color: var(--weui-LINK);">【收藏系列】JS灵魂之问(下) - 附个人成长经验分享</a></p><p class="ql-align-justify"><a href="http://mp.weixin.qq.com/s?__biz=MjM5NTQ4ODc5MA==&amp;mid=2247484666&amp;idx=3&amp;sn=a85ca89121696c7051ad979c9bc80f0c&amp;chksm=a6f6f18391817895488cc52abbf6a4085d8e6b04c0e441b68261eb222b2227ec75337c4a3bc1&amp;scene=21#wechat_redirect" target="_blank" style="color: var(--weui-LINK);">【收藏系列】JS灵魂之问, 是否有offer看你接到多少个(中)</a></p><p class="ql-align-justify"><a href="http://mp.weixin.qq.com/s?__biz=MjM5NTQ4ODc5MA==&amp;mid=2247484655&amp;idx=3&amp;sn=0f845d12a194e3ca3e124cba312a3342&amp;chksm=a6f6f19691817880db6f785622f2455bedef34be13c5524485f778e4b50c6ba5a09cb3e55cac&amp;scene=21#wechat_redirect" target="_blank" style="color: var(--weui-LINK);">【收藏系列】JS灵魂之问, 请问你能接得住几个？(上)</a></p><p class="ql-align-justify"><a href="http://mp.weixin.qq.com/s?__biz=MjM5NTQ4ODc5MA==&amp;mid=2247484643&amp;idx=4&amp;sn=df570f34bd514568ed5c2abb1a990719&amp;chksm=a6f6f19a9181788c3d44c7a48bc394ae79222410dd108e14e92d99f6c9e7c1b0fb3aff24d164&amp;scene=21#wechat_redirect" target="_blank" style="color: var(--weui-LINK);">【大厂面试】20道超高频题目</a></p><p class="ql-align-justify"><a href="http://mp.weixin.qq.com/s?__biz=MjM5NTQ4ODc5MA==&amp;mid=2247484571&amp;idx=2&amp;sn=ee2f2873e9f5b6cd756a824cf44f807b&amp;chksm=a6f6f1e2918178f4b7fde68f36978cf90f2e30b895a7863d19352682b5810b1019d53ec2ee77&amp;scene=21#wechat_redirect" target="_blank" style="color: var(--weui-LINK);">【JS进阶深挖】完全弄懂数据类型转换(上)</a></p><p class="ql-align-justify"><a href="http://mp.weixin.qq.com/s?__biz=MjM5NTQ4ODc5MA==&amp;mid=2247484555&amp;idx=2&amp;sn=e338b47af731998b1aea0925ffdf3a39&amp;chksm=a6f6f1f2918178e4ae0aab67b49e0169d08356d4d446308d6aa10db1c2ab3a43fd8fd3fbd777&amp;scene=21#wechat_redirect" target="_blank" style="color: var(--weui-LINK);">前端架构师最终面试题！</a></p><p class="ql-align-justify"><a href="http://mp.weixin.qq.com/s?__biz=MjM5NTQ4ODc5MA==&amp;mid=2247484431&amp;idx=5&amp;sn=05c30e0a92f774c4cd338e3b4f637e7b&amp;chksm=a6f6f1769181786029380e3e3bb36c8b29aef5279d5a59863c379adc727d430e396347bcceb0&amp;scene=21#wechat_redirect" target="_blank" style="color: var(--weui-LINK);">48道题JS继承题目【面试官再也难不倒你了系列】</a></p><p class="ql-align-justify"><a href="http://mp.weixin.qq.com/s?__biz=MjM5NTQ4ODc5MA==&amp;mid=2247484361&amp;idx=5&amp;sn=db5ff0bbdd66b3b936bc85fe68dcf773&amp;chksm=a6f6f6b091817fa66a46f06885a76fda90097ce542ce0a81ba91db21c2b16e8f07f272fad5d4&amp;scene=21#wechat_redirect" target="_blank" style="color: var(--weui-LINK);">神奇的arguments笔试题【一天突破一个知识点】</a></p><p class="ql-align-justify"><a href="http://mp.weixin.qq.com/s?__biz=MjM5NTQ4ODc5MA==&amp;mid=2247484344&amp;idx=3&amp;sn=02d60623e63fa1197e207979da834908&amp;chksm=a6f6f6c191817fd797925ef78526be8f5f8a0130cc116edbb4bd6826a6e90a26ab4459e79837&amp;scene=21#wechat_redirect" target="_blank" style="color: var(--weui-LINK);">45道Promise面试题【面试官再也难不倒你了系列】</a></p><p class="ql-align-justify"><a href="http://mp.weixin.qq.com/s?__biz=MjM5NTQ4ODc5MA==&amp;mid=2247484283&amp;idx=5&amp;sn=9b18ba83ec76d647471d2f75a70a1d65&amp;chksm=a6f6f60291817f1432a0a69f7ee63c7fbbf81e472b3a3eb0f725afbb3482154fa6d6f7fa5824&amp;scene=21#wechat_redirect" target="_blank" style="color: var(--weui-LINK);">40道this面试题！面试官再也难不到你</a></p><p class="ql-align-justify"><br></p><p><br></p>